<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>10,001 Processes</title>
  <link rel="stylesheet" href="../css/site.css">
  <link rel="stylesheet" href="css/examples.css">
  <link rel="stylesheet" href="../css/tomorrow-night-eighties.css">
  <script src="../js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <header>
    <h1><a href="../index.html">Cispy</a></h1>
    <p>Communicating Sequential Processes for JavaScript</p>
    <a href="https://github.com/Barandis/cispy">
      <img id="fork-me" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png">
    </a>
  </header>
  <section id="content">
    <h1>10,001 Processes</h1>

    <p>
      This was a nifty little thing that I found on
      <a href="http://swannodette.github.io/2013/08/02/100000-processes">swannodette's blog</a> which demonstrates the
      creation and execution of 10,001 processes in the browser. Just kinda cool, so I decided to implement it with
      Cispy.
    </p>

    <table id="process-10k"></table>

    <p>
      This is 10,001 processes running simultaneously, all communicating over a single channel. 10,000 of these
      processes are responsible for putting values onto the channel, which they do every 1-10 seconds (the time is
      chosen randomly for every process). The values include an index of one of the 10,000 numbers in the display and
      the new digit that should be in that place.
    </p>
    <p>
      The 10,001st process takes these values from the channel as they come in and collects them in a queue. It does
      this through an `alts` call which reads two channels: the one where all of the values are, and a timeout channel
      that closes every 40 milliseconds. When that timeout channel closes, the queued values are all displayed (in one
      of a set of colors that cycles and repeats), the timeout channel is restarted, and the queue begins to fill again.
    </p>
    <p>
      Those who have done multi-threading in other languages will know that 10,000 threads would be impossible within
      memory and CPU constraints. Processes are much lighter in weight though, to the degree that a browser engine can
      handle them fine.
    </p>
    <p>
      Here is the code for your viewing pleasure.
    </p>
    <pre>
      <code id="code"></code>
    </pre>
  </section>
  <script src="../js/cispy.js"></script>
  <script src="js/process-10k.js"></script>
  <script>
    const xhr = new XMLHttpRequest();
    xhr.open('get', 'js/process-10k.js', true);
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4 && xhr.status === 200) {
        const code = document.getElementById('code');
        code.innerText = xhr.responseText;
        hljs.highlightBlock(code);
      }
    };
    xhr.send();
  </script>
</body>
</html>
