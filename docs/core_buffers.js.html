<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/buffers.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cispy.html">cispy</a><ul class='methods'><li data-type='method'><a href="module-cispy.html#~alts">alts</a></li><li data-type='method'><a href="module-cispy.html#~altsAsync">altsAsync</a></li><li data-type='method'><a href="module-cispy.html#~chan">chan</a></li><li data-type='method'><a href="module-cispy.html#~close">close</a></li><li data-type='method'><a href="module-cispy.html#~config">config</a></li><li data-type='method'><a href="module-cispy.html#~droppingBuffer">droppingBuffer</a></li><li data-type='method'><a href="module-cispy.html#~fixedBuffer">fixedBuffer</a></li><li data-type='method'><a href="module-cispy.html#~go">go</a></li><li data-type='method'><a href="module-cispy.html#~goSafe">goSafe</a></li><li data-type='method'><a href="module-cispy.html#~put">put</a></li><li data-type='method'><a href="module-cispy.html#~putAsync">putAsync</a></li><li data-type='method'><a href="module-cispy.html#~sleep">sleep</a></li><li data-type='method'><a href="module-cispy.html#~slidingBuffer">slidingBuffer</a></li><li data-type='method'><a href="module-cispy.html#~spawn">spawn</a></li><li data-type='method'><a href="module-cispy.html#~take">take</a></li><li data-type='method'><a href="module-cispy.html#~takeAsync">takeAsync</a></li><li data-type='method'><a href="module-cispy.html#~takeOrThrow">takeOrThrow</a></li><li data-type='method'><a href="module-cispy.html#~timeout">timeout</a></li></ul></li><li><a href="module-cispy_core_buffers.html">cispy/core/buffers</a></li><li><a href="module-cispy_core_channel.html">cispy/core/channel</a></li><li><a href="module-cispy_util.html">cispy/util</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-cispy_core_buffers-Buffer.html">Buffer</a><ul class='methods'><li data-type='method'><a href="module-cispy_core_buffers-Buffer.html#remove">remove</a></li></ul></li><li><a href="module-cispy_core_buffers-DroppingBuffer.html">DroppingBuffer</a><ul class='methods'><li data-type='method'><a href="module-cispy_core_buffers-DroppingBuffer.html#add">add</a></li></ul></li><li><a href="module-cispy_core_buffers-FixedBuffer.html">FixedBuffer</a><ul class='methods'><li data-type='method'><a href="module-cispy_core_buffers-FixedBuffer.html#add">add</a></li></ul></li><li><a href="module-cispy_core_buffers-Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="module-cispy_core_buffers-Queue.html#dequeue">dequeue</a></li><li data-type='method'><a href="module-cispy_core_buffers-Queue.html#enqueue">enqueue</a></li><li data-type='method'><a href="module-cispy_core_buffers-Queue.html#filter">filter</a></li><li data-type='method'><a href="module-cispy_core_buffers-Queue.html#peek">peek</a></li></ul></li><li><a href="module-cispy_core_buffers-SlidingBuffer.html">SlidingBuffer</a><ul class='methods'><li data-type='method'><a href="module-cispy_core_buffers-SlidingBuffer.html#add">add</a></li></ul></li><li><a href="module-cispy_core_channel-Channel.html">Channel</a></li><li><a href="module-cispy_util-CispyUtil.html">CispyUtil</a><ul class='methods'><li data-type='method'><a href="module-cispy_util-CispyUtil.html#.into">into</a></li><li data-type='method'><a href="module-cispy_util-CispyUtil.html#.onto">onto</a></li><li data-type='method'><a href="module-cispy_util-CispyUtil.html#.reduce">reduce</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">core/buffers.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright (c) 2017 Thomas Otterson
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Provides several types of buffers usable in buffered channels. These are all built on a small, efficient queue (also
 * provided) which is in turn backed by a JavaScript array.
 *
 * @module cispy/core/buffers
 */

/**
 * A symbol returned whenever an attempt is made to get an item from an empty buffer.
 *
 * @const {Symbol}
 * @private
 */
const EMPTY = Symbol('EMPTY');

/**
 * A general purpose, highly efficient JavaScript queue. It is backed by a JavaScript array, but it does not
 * use `unshift` to take elements off the array because unshift causes elements to be copied every time it's used.
 * Instead, a pointer is maintained that keeps track of the location of the next element to be dequeued, and when that
 * dequeue happens, the pointer simply moves. When the empty space at the head of the array gets large enough, it's
 * removed by a single slice operation.
 *
 * Putting elements into the queue is just done with a basic `push`, which *is* highly efficient.
 *
 * This type of queue is possible in JavaScript because JS arrays are resizable. In languages with fixed-size arrays,
 * a resizing operation would have to be run each time the queue fills.
 *
 * @namespace Queue
 */

/**
 * Creates a new queue. This queue is created empty, with a backing array of length 0.
 *
 * @returns {module:cispy/core/buffers~Queue} a new, empty queue
 * @private
 */
function queue() {
  const obj = {
    store: [],
    pointer: 0,

    /**
     * Returns the number of elements stored in the queue. This may or may not equal the length of the backing store.
     *
     * @name count
     * @memberOf module:cispy/core/buffers~Queue
     * @instance
     * @type {number}
     * @readonly
     */
    get count() {
      return this.store.length - this.pointer;
    },

    /**
     * Returns `true` if the queue is empty.
     *
     * @name empty
     * @memberOf module:cispy/core/buffers~Queue
     * @instance
     * @type {boolean}
     * @readonly
     */
    get empty() {
      return this.store.length === 0;
    },

    /**
     * Adds an item to the queue.
     *
     * @function enqueue
     * @memberOf module:cispy/core/buffers~Queue
     * @instance
     * @param {*} item The value being added to the queue.
     */
    enqueue(item) {
      this.store.push(item);
    },

    /**
     * Removes an item from the queue and returns that item. If the removal causes the amount of empty space at the
     * head of the backing store to exceed a threshold, that empty space is removed.
     *
     * @function dequeue
     * @memberOf module:cispy/core/buffers~Queue
     * @instance
     * @return {*} The oldest stored item in the queue.
     */
    dequeue() {
      if (this.empty) {
        return EMPTY;
      }

      const item = this.store[this.pointer];
      // Removes the items in the backing array before the current pointer, if there is enough empty space before the
      // pointer to justify it.
      if (++this.pointer * 2 >= this.store.length) {
        this.store = this.store.slice(this.pointer);
        this.pointer = 0;
      }
      return item;
    },

    /**
     * Returns the next item in the queue without removing it.
     *
     * @function peek
     * @memberOf module:cispy/core/buffers~Queue
     * @instance
     * @return {*} The oldest item stored in the queue.
     */
    peek() {
      return this.empty ? EMPTY : this.store[this.pointer];
    },

    /**
     * Filters out any item in the queue that does not cause the supplied predicate functoin to return `true` when
     * passed that item. This is not exactly a general purpose queue operation, but we need it with channels that will
     * occasionally want to get rid of inactive handlers.
     *
     * @function filter
     * @memberOf module:cispy/core/buffers~Queue
     * @instance
     * @param {Function} fn The predicate function that determines whether an element remains in the queue.
     */
    filter(fn) {
      for (let i = 0, { count } = this; i &lt; count; ++i) {
        const item = this.dequeue();
        if (fn(item)) {
          this.enqueue(item);
        }
      }
    }
  };

  return obj;
}

// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Buffer implementations
//
// Each of the three buffers has the same three properties and two operations. The difference between them is the
// behavior of the `full` property and of the `add` operation.
//
// size: the largest number of items that can be in the buffer at once.
// count: the actual number of items in the buffer.
// full: whether or not the buffer is full.
// add: adds an item to the buffer.
// remove: removes an item from the buffer (and returns it).
// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The base for buffer classes, containing the common functionality between all of them. The only properties that
 * actually vary between buffer types are `full` (whether or not the buffer is full) and `add` (because different
 * buffers have different behavior when something is added to a full buffer).
 *
 * These buffers are each backed by a {@link Queue}.
 *
 * @namespace Buffer
 */

/**
 * Creates a base buffer of the given size.
 *
 * @param  {number} size the maximum number of items that the new buffer can hold.
 * @return {module:cispy.buffers~Buffer} the new buffer.
 * @private
 */
function base(size) {
  const q = queue();

  return {
    /**
     * The queue that backs this buffer.
     *
     * @name queue
     * @memberOf module:cispy/core/buffers~Buffer
     * @instance
     * @type {module:cispy/core/buffers~Queue}
     * @readonly
     */
    get queue() {
      return q;
    },

    /**
     * The size of the buffer.
     *
     * This is *not* the number of elements in the buffer; it is the number of items that can be stored without the
     * buffer overflowing. It is static and is set at creation time.
     *
     * @name size
     * @memberOf module:cispy/core/buffers~Buffer
     * @instance
     * @type {number}
     * @readonly
     */
    get size() {
      return size;
    },

    /**
     * The number of items currently being stored by the buffer.
     *
     * @name count
     * @memberOf module:cispy/core/buffers~Buffer
     * @instance
     * @type {number}
     * @readonly
     */
    get count() {
      return this.queue.count;
    },

    /**
     * Removes and returns the oldest item in the buffer.
     *
     * @function remove
     * @memberOf module:cispy/core/buffers~Buffer
     * @instance
     * @return {*} The oldest item in the buffer.
     */
    remove() {
      return this.queue.dequeue();
    }
  };
}

/**
 * Creates a fixed buffer of the given size.
 *
 * @param  {number} size The number of items at (or over) which the buffer is considered *full*.
 * @return {module:cispy/core/buffers~FixedBuffer} The new fixed buffer.
 * @private
 */
function fixed(size) {
  /**
   * A buffer implementation that never discards buffered items when a new item is added.
   *
   * This buffer has a concept of *full*, but it's a soft limit. If the size of the buffer is exceeded, added items are
   * still stored. {@link module:cispy/core/buffers~FixedBuffer#full|full} returns `true` any time that the size is
   * reached or exceeded, so it's entirely possible to call {@link module:cispy/core/buffers~Buffer#remove|remove} on a
   * full buffer and have it still be full.
   *
   * @namespace FixedBuffer
   * @augments {module:cispy/core/buffers~Buffer}
   */
  return Object.assign(
    Object.create(base(size), {
      // Object.assign doesn't handle getters and setters properly, so we add this getter as a property descriptor
      // in the second argument of Object.create instead.
      full: {
        /**
         * Whether or not the buffer has as many or more items stored as its
         * {@link module:cispy/core/buffers~Buffer#size|size}.
         *
         * @name full
         * @memberOf module:cispy/core/buffers~FixedBuffer
         * @instance
         * @type {number}
         * @readonly
         */
        get() {
          return this.queue.count >= this.size;
        }
      }
    }),
    {
      /**
       * Adds one or more items to the buffer. These items will be added even if the buffer is full.
       *
       * @function add
       * @memberOf module:cispy/core/buffers~FixedBuffer
       * @instance
       * @param {...*} items The items to be added to the buffer.
       */
      add(...items) {
        for (const item of items) {
          this.queue.enqueue(item);
        }
      }
    }
  );
}

/**
 * Creates a dropping buffer of the given size.
 *
 * @param  {number} size the number of items at which adding a new item results in that item being dropped.
 * @return {DroppingBuffer} the new dropping buffer.
 * @private
 */
function dropping(size) {
  /**
   * A buffer implementation that drops newly added items when the buffer is full.
   *
   * This dropping behavior is silent: the new item is simply not added to the queue. Note taht this buffer is never
   * `full` because it can always be added to wiehtout exceeding the size, even if that 'adding' doesn't result in a new
   * item actually appearing in the buffer.
   *
   * @namespace DroppingBuffer
   * @extends {module:cispy/core/buffers~Buffer}
   */
  return Object.assign(
    Object.create(base(size), {
      full: {
        /**
         * Whether or not the buffer is full. As a {@link module:cispy/core/buffers~DroppingBuffer|DroppingBuffer} is
         * never considered full, this will always return `false`.
         *
         * @name full
         * @memberOf module:cispy/core/buffers~DroppingBuffer
         * @instance
         * @type {number}
         * @readonly
         */
        get() {
          return false;
        }
      }
    }),
    {
      /**
       * Adds one or more items to the buffer. If the buffer has already reached its capacity, then the item is silently
       * dropped instead.
       *
       * @function add
       * @memberOf module:cispy/core/buffers~DroppingBuffer
       * @instance
       * @param {...*} items the items added to the buffer.
       */
      add(...items) {
        for (const item of items) {
          if (this.queue.count &lt; this.size) {
            this.queue.enqueue(item);
          }
        }
      }
    }
  );
}

/**
 * Creates a sliding buffer of the given size.
 *
 * @param  {number} size the number of items at which adding a new item results in that item being dropped.
 * @return {SlidingBuffer} the new sliding buffer.
 * @private
 */
function sliding(size) {
  /**
   * A buffer implementation that drops the oldest item when an item is added to a full buffer.
   *
   * This is very similar to {@link module:cispy/core/buffers~DroppingBuffer|DroppingBuffer}; the only difference is in
   * what happens when an item is added. In this buffer, the new item is indeed added to the buffer, but in order to
   * keep the count of the buffer at or below its size, the oldest item in the buffer is silently dropped.
   *
   * @namespace SlidingBuffer
   * @extends {module:cispy/core/buffers~Buffer}
   */
  return Object.assign(
    Object.create(base(size), {
        /**
         * Whether or not the buffer is full. As a {@link module:cispy/core/buffers~SlidingBuffer|SlidingBuffer} is
         * never considered full, this will always return `false`.
         *
         * @name full
         * @memberOf module:cispy/core/buffers~SlidingBuffer
         * @instance
         * @type {number}
         * @readonly
         */
      full: {
        get() {
          return false;
        }
      }
    }),
    {
      /**
       * Adds one or more items to the buffer. If the buffer has already reached its capacity, then the oldest items in
       * the buffer are dropped to make way for the new items.
       *
       * @function add
       * @memberOf module:cispy/core/buffers~SlidingBuffer
       * @instance
       * @param {...*} items The items to be added to the buffer.
       */
      add(...items) {
        for (const item of items) {
          if (this.queue.count === this.size) {
            this.queue.dequeue();
          }
          this.queue.enqueue(item);
        }
      }
    }
  );
}

module.exports = {
  EMPTY,
  queue,
  fixed,
  dropping,
  sliding
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.4</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
